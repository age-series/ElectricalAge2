// This is the RPC variant of a component definition.
//
// It's passed over the wire during initialization, watchdogs firing,
// or if the client explicitly requests a component summary. (E.g. for WAILA.)
//
// It's *not* saved to disk, as there is quite a bit of data which the client never needs. Those protobuf
// variants exist only inside the core module.
syntax = "proto3";
package org.eln2.proto.simulator;
option optimize_for = LITE_RUNTIME;

// Each field is only filled in when it makes sense, i.e. a crash report will include everything,
// as might a watchdog firing or WAILA-induced state request, but an AddComponent request won't
// include the (unknown) electrical state. It might include thermal state.
message Component {
    // This value is monotonically increasing for a given server, and never reused.
    int64 id = 1;

    // This is the computed electrical and thermal state, usually sent server->client.
    ElectricalState electrical_state = 2;
    ThermalState thermal_state = 3;

    // These are initialization parameters, sent client->server.
    Watchdog watchdog = 4;
    ThermalParams thermal = 5;
    Location location = 6;
    // In general, default to adding components to this list (handling them core-side) rather than
    // emulating them client-side. E.g, a lightbulb is better simulated in core than on the client.
    // This is both for performance (it's much easier to multithread Core than a minecraft server),
    // and for code de-duplication.
    oneof type {
        // Circuit primitives:
        VoltageSource voltage_source = 10;
        CurrentSource current_source = 11;
        Resistor resistor = 12;
        Inductor inductor = 13;
        Capacitor capacitor = 14;
        // Lights:
        IncandescentLight incandescent_light = 20;
        FluorescentLight fluorescent_light = 21;
    }
}

// Standard thermal parameters.
message ThermalParams {
    float thermal_mass = 1;
    // TODO: Fill in.
}

// Standard thermal state.
message ThermalState {
    float temperature = 1;
}

// Standard electrical state.
message ElectricalState {
    message Pin {
        float voltage = 1;
        float current = 2;
    }
    // Pin 0, pin 1, pin 2, etc.
    repeated Pin pin = 1;
}

// Standard watchdogs.
//
// The simulator won't take direct action in response to a component exceeding its physical limits. Instead it will
// notify the client that this has happened. The client can then make its own decisions based on gameplay integration.
//
// Not all watchdog limits make sense for all components.
// For components with multiple pins, this applies to all of them. Any watchdogs that shouldn't are defined per-component.
message Watchdog {
    // 'Low' values should typically be negative, if set.
    float voltage_low = 1;
    float voltage_high = 2;
    float current_low = 3;
    float current_high = 4;
    float temperature_low = 5; // Uh... for a chiller, maybe? In kelvin, of course.
    float temperature_high = 6;
}

// In-world positioning.
// This has no bearing on the simulation, unless perhaps if we implement a deeper thermal simulation.
// Currently it's purely informational.
message Location {
    // Any of these may be missing if the question makes no sense, e.g. z-value for a 2D game.
    sint32 x = 1;
    sint32 y = 2;
    sint32 z = 3;
    sint32 world_id = 4;
}

// Pins: 1
message VoltageSource {
    float voltage = 1;
}

// Pins: 1
message CurrentSource {
    float current = 1;
}

// Pins: 2, one for each side.
message Resistor {
    float ohms = 1;
}

// Pins: 2, one for each side.
message Inductor {
    float inductance = 1;
    // Energy stored, in joules; sent to the client.
    float energy = 2;
}

// Pins: 2, one for each side.
message Capacitor {
    float capacitance = 1;
    // If set, fire a watchdog if U(P0) > U(P1).
    bool polar = 2;
    // Energy stored, in joules; sent to the client.
    float energy = 3;
}

// Pins: 1. This is effectively a resistor to ground.
//
// The server will fire a watchdog whenever the radiant flux changes by more than a configurable value,
// allowing the client to update in-game lighting without repeatedly asking for its electrical values.
message IncandescentLight {
    float ohms = 1;
    float efficiency = 2; // Visible radiant flux per watt. The rest becomes heat.
}

// Pins: 1, ditto.
message FluorescentLight {
    float ohms = 1;
    float efficiency = 2;
    // This may look similar to the above, but the voltage response is quite different (and possibly nonlinear).
    // Fluorescents tend to flicker during startup, or at low voltage. Depending on the game we may
    // be able to update lighting dynamically, but we don't want one watchdog firing per tick.
    // This field is set by the server accordingly.
    int32 stability_percent = 3; // 0 to 100; fraction of time it should be on.
}
